<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess Online</title>
    <link rel="stylesheet" href="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --font-family: 'Roboto', sans-serif;
            --border-radius: 8px;
            --shadow: 0 4px 12px rgba(0,0,0,0.1);
        }

        body {
            font-family: var(--font-family);
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            transition: background-color 0.4s, color 0.4s;
        }

        .container {
            display: flex;
            flex-wrap: wrap;
            gap: 25px;
            padding: 20px;
            max-width: 1400px;
            width: 100%;
            justify-content: center;
        }

        /* --- THEMES --- */
        body.theme-light { background-color: #f0f2f5; color: #1c1e21; }
        body.theme-light .side-panel, body.theme-light .game-controls { background-color: #ffffff; border: 1px solid #ddd; }
        body.theme-light #board { border: 8px solid #dcdcdc; }
        body.theme-light #moveHistory { background-color: #f7f7f7; }

        body.theme-dark { background-color: #18191a; color: #e4e6eb; }
        body.theme-dark .side-panel, body.theme-dark .game-controls { background-color: #242526; border: 1px solid #3a3b3c; }
        body.theme-dark #board { border: 8px solid #4d4d4d; }
        body.theme-dark #moveHistory { background-color: #3a3b3c; }
        body.theme-dark select, body.theme-dark input { background-color: #3a3b3c; color: #e4e6eb; border-color: #555; }

        body.theme-blue { background-color: #1a237e; color: #e8eaf6; }
        body.theme-blue .side-panel, body.theme-blue .game-controls { background-color: #283593; border: 1px solid #3f51b5; }
        body.theme-blue #board { border: 8px solid #3f51b5; }
        body.theme-blue #moveHistory { background-color: #3f51b5; }

        body.theme-green { background-color: #2e7d32; color: #e8f5e9; }
        body.theme-green .side-panel, body.theme-green .game-controls { background-color: #388e3c; border: 1px solid #4caf50; }
        body.theme-green #board { border: 8px solid #4caf50; }
        body.theme-green #moveHistory { background-color: #66bb6a; }

        body.theme-wood { background-image: url('https://www.transparenttextures.com/patterns/wood-pattern.png'); background-color: #8d6e63; color: #ffffff; }
        body.theme-wood .side-panel, body.theme-wood .game-controls { background-color: rgba(93, 64, 55, 0.85); border: 1px solid #a1887f; backdrop-filter: blur(5px); }
        body.theme-wood #board { border: 8px solid #5d4037; box-shadow: 0 10px 30px rgba(0,0,0,0.5); }
        body.theme-wood #moveHistory { background-color: #a1887f; }

        .board-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #board {
            width: clamp(320px, 90vw, 600px);
            box-shadow: var(--shadow);
            border-radius: 4px;
        }

        .side-panel {
            width: 250px;
            padding: 20px;
            border-radius: var(--border-radius);
            box-shadow: var(--shadow);
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .side-panel h3 {
            margin: 0 0 10px 0;
            font-weight: 500;
            padding-bottom: 5px;
            border-bottom: 2px solid;
            border-color: inherit;
        }

        .captured-pieces {
            min-height: 40px;
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
        }
        .captured-pieces img { width: 32px; height: 32px; }

        #moveHistory {
            height: 400px;
            overflow-y: auto;
            border-radius: 4px;
            padding: 10px;
            font-family: 'Courier New', monospace;
        }
        .move-row { display: flex; padding: 4px 2px; border-radius: 3px; }
        .move-row:nth-child(odd) { background-color: rgba(0,0,0,0.05); }
        .move-number { width: 35px; color: #888; font-weight: bold; }
        .move { flex: 1; padding: 0 5px; }

        /* --- Board Highlights --- */
        .highlight-legal { box-shadow: inset 0 0 3px 3px rgba(255, 255, 0, 0.7); }
        .highlight-selected { box-shadow: inset 0 0 3px 3px rgba(20, 85, 30, 0.8); }
        .highlight-last-move { background-color: rgba(155, 199, 0, 0.41); }
        .highlight-premove { background-color: rgba(255, 165, 0, 0.5); }
        .highlight-check {
            background: radial-gradient(ellipse at center, rgba(255,0,0,0.6) 0%, rgba(255,0,0,0) 70%);
        }

        .game-controls {
            width: 100%;
            padding: 20px;
            border-radius: var(--border-radius);
            box-shadow: var(--shadow);
            text-align: center;
            display: flex;
            flex-direction: column;
            gap: 15px;
            max-width: 900px;
        }

        .room-actions { display: flex; justify-content: center; gap: 10px; align-items: center; }
        
        button {
            padding: 12px 24px;
            font-size: 16px;
            border: none;
            border-radius: var(--border-radius);
            background: #2196F3;
            color: white;
            cursor: pointer;
            transition: background 0.3s, transform 0.2s;
            font-weight: 500;
        }
        button:hover:not(:disabled) { background: #1976D2; transform: translateY(-2px); }
        button:disabled { background: #ccc; cursor: not-allowed; }
        
        #roomCodeInput {
            padding: 12px;
            font-size: 16px;
            border: 1px solid #ddd;
            border-radius: var(--border-radius);
            text-align: center;
            width: 180px;
            text-transform: uppercase;
        }
        
        #status, #roomStatus, #connectionStatus { font-weight: 500; font-size: 1.1em; height: 25px; }
        .theme-switcher { position: fixed; top: 15px; right: 15px; z-index: 1000; }
        #themeSelect { padding: 8px; border-radius: 4px; border: 1px solid #ddd; }

        .game-end-overlay {
            display: none;
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 999;
            justify-content: center; align-items: center;
        }
        .game-end-message {
            background: white; padding: 40px; border-radius: 10px;
            text-align: center; color: black;
        }
    </style>
</head>
<body class="theme-light">

    <div class="theme-switcher">
        <select id="themeSelect">
            <option value="light">Light</option>
            <option value="dark">Dark</option>
            <option value="blue">Blue</option>
            <option value="green">Green</option>
            <option value="wood">Wood</option>
        </select>
    </div>

    <div class="game-end-overlay">
        <div class="game-end-message">
            <h2 id="endGameMessage"></h2>
            <p>Refresh the page to start a new game.</p>
        </div>
    </div>

    <div class="container">
        <div class="side-panel">
            <h3>White's Captures</h3>
            <div id="capturedByBlack" class="captured-pieces"></div>
            <h3>Move History</h3>
            <div id="moveHistory"></div>
        </div>

        <div class="board-wrapper">
            <div class="game-controls">
                <h1>Chess Online</h1>
                <div id="connectionStatus">Connecting...</div>
                <div id="status">Create or join a room to play.</div>
                <div id="roomStatus"></div>
                <div class="room-actions">
                    <button id="createRoomBtn">Create Room</button>
                    <span>or</span>
                    <input type="text" id="roomCodeInput" placeholder="Enter Room Code" maxlength="6">
                    <button id="joinRoomBtn">Join Room</button>
                </div>
            </div>
            <div id="board" style="margin-top: 20px;"></div>
        </div>
        
        <div class="side-panel">
            <h3>Black's Captures</h3>
            <div id="capturedByWhite" class="captured-pieces"></div>
            <h3>Game Info</h3>
            <div id="playerInfo">Your color: N/A</div>
        </div>
    </div>

    <audio id="moveSound" src="https://images.chesscomfiles.com/chess-themes/sounds/_MP3_/default/move-self.mp3" preload="auto"></audio>
    <audio id="captureSound" src="https://images.chesscomfiles.com/chess-themes/sounds/_MP3_/default/capture.mp3" preload="auto"></audio>

    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>
    <script src="/socket.io/socket.io.js"></script>
    <script>
        $(function() {
            class ChessGame {
                constructor() {
                    this.socket = io({
                        reconnection: true,
                        reconnectionAttempts: 5,
                        reconnectionDelay: 1000,
                    });
                    this.board = null;
                    this.game = new Chess();
                    this.playerColor = null;
                    this.currentRoom = null;
                    this.selectedSquare = null;
                    this.premove = null;

                    this.elements = {
                        status: $('#status'),
                        roomStatus: $('#roomStatus'),
                        connectionStatus: $('#connectionStatus'),
                        moveHistory: $('#moveHistory'),
                        capturedByWhite: $('#capturedByWhite'),
                        capturedByBlack: $('#capturedByBlack'),
                        createRoomBtn: $('#createRoomBtn'),
                        joinRoomBtn: $('#joinRoomBtn'),
                        roomCodeInput: $('#roomCodeInput'),
                        playerInfo: $('#playerInfo'),
                        endGameOverlay: $('.game-end-overlay'),
                        endGameMessage: $('#endGameMessage'),
                    };
                    
                    this.sounds = {
                        move: $('#moveSound')[0],
                        capture: $('#captureSound')[0],
                    };

                    this.bindSocketEvents();
                    this.bindUIEvents();
                    this.initBoard();
                }

                // --- Event Binding ---
                bindSocketEvents() {
                    this.socket.on('connect', () => this.updateConnectionStatus('Connected', true));
                    this.socket.on('disconnect', () => this.updateConnectionStatus('Disconnected', false));
                    this.socket.on('reconnecting', () => this.updateConnectionStatus('Reconnecting...', false));

                    this.socket.on('roomCreated', (data) => this.handleRoomCreated(data));
                    this.socket.on('gameStart', (data) => this.handleGameStart(data));
                    this.socket.on('moveMade', (data) => this.handleMoveMade(data));
                    this.socket.on('gameOver', (message) => this.handleGameOver(message));
                    this.socket.on('playerLeft', (message) => this.handleGameOver(message));
                    this.socket.on('roomError', (message) => alert(message));
                }

                bindUIEvents() {
                    this.elements.createRoomBtn.on('click', () => this.socket.emit('createRoom'));
                    this.elements.joinRoomBtn.on('click', () => {
                        const roomCode = this.elements.roomCodeInput.val().trim().toUpperCase();
                        if (roomCode) this.socket.emit('joinRoom', roomCode);
                    });
                     $('#themeSelect').on('change', (e) => {
                        $('body').removeClass().addClass(`theme-${$(e.target).val()}`);
                    });
                }
                
                // --- Board and Game Logic ---
                initBoard() {
                    this.board = Chessboard('board', {
                        draggable: true,
                        position: 'start',
                        onDragStart: (source, piece) => this.onDragStart(source, piece),
                        onDrop: (source, target) => this.onDrop(source, target),
                        onSnapEnd: () => this.board.position(this.game.fen()),
                    });
                    $(window).resize(this.board.resize);
                }
                
                onDragStart(source, piece) {
                    if (this.game.isGameOver() || !this.playerColor) return false;
                    if (this.game.turn() !== this.playerColor) return false;
                    if (piece.search(new RegExp(`^${this.playerColor}`)) === -1) return false;
                }

                onDrop(source, target) {
                    if (source === target) return;
                    
                    // If it's not our turn, register a premove
                    if (this.game.turn() !== this.playerColor) {
                        this.setPremove(source, target);
                        return 'snapback';
                    }

                    this.makeMove(source, target);
                }
                
                makeMove(from, to) {
                    const move = this.game.move({ from, to, promotion: 'q' });
                    
                    if (move === null) {
                        return 'snapback';
                    }

                    this.socket.emit('move', {
                        roomCode: this.currentRoom,
                        from,
                        to,
                    });
                }

                setPremove(from, to) {
                    this.clearPremoveHighlight();
                    this.premove = { from, to };
                    $(`.square-${from}`).addClass('highlight-premove');
                    $(`.square-${to}`).addClass('highlight-premove');
                    this.elements.status.text(`Premove set: ${from}-${to}`);
                }

                tryPremove() {
                    if (this.premove && this.game.turn() === this.playerColor) {
                        const { from, to } = this.premove;
                        this.premove = null;
                        this.clearPremoveHighlight();
                        this.makeMove(from, to);
                    }
                }
                
                // --- Socket Event Handlers ---
                handleRoomCreated(data) {
                    this.currentRoom = data.roomCode;
                    this.elements.roomStatus.text(`Room Code: ${this.currentRoom} - Waiting for opponent...`);
                    this.elements.createRoomBtn.prop('disabled', true);
                    this.elements.joinRoomBtn.prop('disabled', true);
                }
                
                handleGameStart(data) {
                    this.playerColor = this.socket.id === data.white ? 'w' : 'b';
                    this.board.orientation(this.playerColor === 'w' ? 'white' : 'black');
                    this.elements.playerInfo.text(`You are ${this.playerColor === 'w' ? 'White' : 'Black'}`);
                    this.elements.roomStatus.text(`Game started in room ${this.currentRoom}!`);
                    this.elements.createRoomBtn.hide();
                    this.elements.joinRoomBtn.hide();
                    this.elements.roomCodeInput.hide();
                    this.updateAll();
                }

                handleMoveMade(data) {
                    const move = this.game.move({ from: data.from, to: data.to, promotion: 'q' });
                    if (move) {
                        this.playSound(move.captured);
                        this.updateAll();
                        this.highlightLastMove(data.from, data.to);
                        if (this.game.turn() === this.playerColor) {
                            this.tryPremove();
                        }
                    }
                }
                
                handleGameOver(message) {
                    this.elements.endGameMessage.text(message);
                    this.elements.endGameOverlay.css('display', 'flex');
                }

                // --- UI and State Updates ---
                updateAll() {
                    this.board.position(this.game.fen());
                    this.updateStatus();
                    this.updateMoveHistory();
                    this.updateCapturedPieces();
                    this.highlightKingInCheck();
                }

                updateStatus() {
                    let statusText = '';
                    const turn = this.game.turn() === 'w' ? 'White' : 'Black';

                    if (this.game.isCheckmate()) {
                        statusText = `Checkmate! ${turn === 'White' ? 'Black' : 'White'} wins.`;
                    } else if (this.game.isDraw()) {
                        statusText = 'Draw!';
                    } else {
                        statusText = `${turn}'s turn.`;
                        if (this.game.in_check()) {
                            statusText += ' (in check)';
                        }
                    }
                    this.elements.status.text(statusText);
                }
                
                updateMoveHistory() {
                    const history = this.game.history({ verbose: true });
                    this.elements.moveHistory.empty();
                    for (let i = 0; i < history.length; i += 2) {
                        const moveNumber = i / 2 + 1;
                        const whiteMove = history[i] ? history[i].san : '';
                        const blackMove = history[i+1] ? history[i+1].san : '';
                        this.elements.moveHistory.append(
                            `<div class="move-row">
                                <span class="move-number">${moveNumber}.</span>
                                <span class="move">${whiteMove}</span>
                                <span class="move">${blackMove}</span>
                            </div>`
                        );
                    }
                    this.elements.moveHistory.scrollTop(this.elements.moveHistory[0].scrollHeight);
                }

                updateCapturedPieces() {
                    const initialCounts = { p: 8, r: 2, n: 2, b: 2, q: 1 };
                    const capturedBy = { w: [], b: [] };
                    const pieceChars = Object.keys(initialCounts);
                    
                    const fen = this.game.fen().split(' ')[0];
                    
                    pieceChars.forEach(p => {
                        const whitePiece = new RegExp(p.toUpperCase(), "g");
                        const blackPiece = new RegExp(p.toLowerCase(), "g");
                        const whiteCount = (fen.match(whitePiece) || []).length;
                        const blackCount = (fen.match(blackPiece) || []).length;
                        
                        for (let i = 0; i < initialCounts[p] - whiteCount; i++) capturedBy.b.push(`w${p.toUpperCase()}`);
                        for (let i = 0; i < initialCounts[p] - blackCount; i++) capturedBy.w.push(`b${p.toUpperCase()}`);
                    });

                    const pieceUrl = (p) => `https://chessboardjs.com/img/chesspieces/wikipedia/${p}.png`;
                    this.elements.capturedByWhite.html(capturedBy.w.map(p => `<img src="${pieceUrl(p)}" alt="${p}">`).join(''));
                    this.elements.capturedByBlack.html(capturedBy.b.map(p => `<img src="${pieceUrl(p)}" alt="${p}">`).join(''));
                }
                
                highlightLastMove(from, to) {
                    $('.square-55d63').removeClass('highlight-last-move');
                    $(`.square-${from}`).addClass('highlight-last-move');
                    $(`.square-${to}`).addClass('highlight-last-move');
                }

                clearPremoveHighlight() {
                    $('.square-55d63').removeClass('highlight-premove');
                }

                highlightKingInCheck() {
                    $('.square-55d63').removeClass('highlight-check');
                    if (this.game.in_check()) {
                        const kingPos = this.findKing(this.game.turn());
                        if (kingPos) {
                            $(`.square-${kingPos}`).addClass('highlight-check');
                        }
                    }
                }

                findKing(color) {
                    const board = this.game.board();
                    for (let i = 0; i < 8; i++) {
                        for (let j = 0; j < 8; j++) {
                            const piece = board[i][j];
                            if (piece && piece.type === 'k' && piece.color === color) {
                                return String.fromCharCode(97 + j) + (8 - i);
                            }
                        }
                    }
                    return null;
                }
                
                updateConnectionStatus(text, isConnected) {
                    this.elements.connectionStatus.text(text).css('color', isConnected ? '#4caf50' : '#f44336');
                }
                
                playSound(isCapture) {
                    (isCapture ? this.sounds.capture : this.sounds.move).play().catch(e => console.log("Audio play failed."));
                }
            }
            window.chessGame = new ChessGame();
        });
    </script>
</body>
</html>
