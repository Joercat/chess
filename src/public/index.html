<!DOCTYPE html>
<html>
<head>
    <title>Chess Online</title>
    <link rel="stylesheet" href="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.css">
    <style>
        
body {
    transition: background-color 0.3s, color 0.3s;
    margin: 0;
    padding: 0;
    font-family: Arial, sans-serif;
}

.container {
    max-width: 1200px;
    margin: 0 auto;
    padding: 20px;
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
}

body.theme-light {
    background-color: #ffffff;
    color: #000000;
}
body.theme-light .side-panel {
    background-color: #f0f0f0;
    border: 5px solid black;
}
body.theme-light #board {
    opacity: 1;
    border: 5px solid black;
}

body.theme-dark {
    background-color: #2c2c2c;
    color: #fff;
}
body.theme-dark .side-panel {
    background-color: #1e1e1e;
    border: 5px solid white;
}
body.theme-dark #board {
    opacity: 0.7;
    border: 5px solid white;
}

body.theme-blue {
    background-color: #1a237e;
    color: #fff;
}
body.theme-blue .side-panel {
    background-color: #0d1642;
    border: 5px solid white;
}
body.theme-blue #board {
    opacity: 0.85;
    border: 5px solid white;
}

.board-container {
    display: flex;
    gap: 20px;
}

#board {
    width: 600px;
    box-shadow: 0 0 10px rgba(0,0,0,0.3);
}

.highlight-square {
    box-shadow: inset 0 0 3px 3px yellow !important;
}

.selected-square {
    box-shadow: inset 0 0 3px 3px blue !important;
}

.last-move {
    background-color: rgba(155, 199, 0, 0.41) !important;
}

.premove {
    background-color: rgba(255, 0, 0, 0.5) !important;
}

.in-check {
    position: relative;
}

.in-check::before {
    content: '';
    position: absolute;
    width: 81%;
    height: 81%;
    border-radius: 50%;
    background-color: rgba(255, 0, 0, 0.6);
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
}

.side-panel {
    width: 200px;
    padding: 20px;
    background-color: #f0f0f0;
    border-radius: 8px;
    box-shadow: 0 0 5px rgba(0,0,0,0.2);
    border: 5px solid black;
}

.captured-pieces {
    margin: 10px 0;
    min-height: 50px;
    display: flex;
    flex-wrap: wrap;
    gap: 5px;
}

.captured-pieces img {
    width: 30px;
    height: 30px;
    transition: transform 0.2s;
}

.captured-pieces img:hover {
    transform: scale(1.2);
}

#moveHistory {
    height: 300px;
    overflow-y: auto;
    border: 1px solid #ddd;
    padding: 10px;
    margin-top: 10px;
    background: white;
    border-radius: 4px;
}

.move-row {
    display: flex;
    margin: 5px 0;
    font-family: 'Courier New', monospace;
}

.move-number {
    width: 30px;
    color: #666;
}

.move {
    flex: 1;
    padding: 0 5px;
}

.game-end-overlay {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.8);
    z-index: 1000;
    justify-content: center;
    align-items: center;
}

.game-end-message {
    background: white;
    padding: 30px;
    border-radius: 10px;
    text-align: center;
    color: black;
}

.theme-switch {
    position: fixed;
    top: 20px;
    right: 20px;
    z-index: 100;
}

#themeSelect {
    padding: 8px;
    border-radius: 4px;
    border: 1px solid #ddd;
    background: white;
    cursor: pointer;
}

.room-controls {
    text-align: center;
    margin: 20px 0;
}

#roomCode {
    padding: 10px;
    font-size: 16px;
    border: 1px solid #ddd;
    border-radius: 4px;
    margin: 0 10px;
}

button {
    padding: 10px 20px;
    font-size: 16px;
    border: none;
    border-radius: 4px;
    background: #2196F3;
    color: white;
    cursor: pointer;
    transition: background 0.3s;
}

button:hover:not(:disabled) {
    background: #1976D2;
}

button:disabled {
    background: #ccc;
    cursor: not-allowed;
}

#roomStatus {
    color: #2196F3;
    font-weight: bold;
    margin-top: 10px;
}

#status {
    font-size: 18px;
    margin: 10px 0;
    text-align: center;
}

.error-message {
    color: #f44336;
    font-weight: bold;
    margin: 10px 0;
    padding: 10px;
    background: rgba(244, 67, 54, 0.1);
    border: 1px solid #f44336;
    border-radius: 4px;
    text-align: center;
}

.success-message {
    color: #4caf50;
    font-weight: bold;
    margin: 10px 0;
    padding: 10px;
    background: rgba(76, 175, 80, 0.1);
    border: 1px solid #4caf50;
    border-radius: 4px;
    text-align: center;
}

.connection-status {
    position: fixed;
    top: 60px;
    right: 20px;
    padding: 5px 10px;
    border-radius: 4px;
    font-size: 12px;
    font-weight: bold;
}

.connection-status.connected {
    background: #4caf50;
    color: white;
}

.connection-status.disconnected {
    background: #f44336;
    color: white;
}

.connection-status.reconnecting {
    background: #ff9800;
    color: white;
}

#errorLog {
    display: none;
    position: fixed;
    bottom: 20px;
    right: 20px;
    width: 300px;
    max-height: 200px;
    overflow-y: auto;
    background: rgba(0, 0, 0, 0.9);
    color: white;
    padding: 10px;
    border-radius: 4px;
    font-size: 12px;
    font-family: monospace;
}

.show-errors {
    position: fixed;
    bottom: 20px;
    right: 20px;
    padding: 5px 10px;
    font-size: 12px;
    background: #f44336;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
}
    </style>
</head>
<body class="theme-light">
    <div class="theme-switch">
        <select id="themeSelect">
            <option value="light">Light Theme</option>
            <option value="dark">Dark Theme</option>
            <option value="blue">Blue Theme</option>
        </select>
    </div>

    <div class="connection-status" id="connectionStatus">Connecting...</div>

    <div class="game-end-overlay">
        <div class="game-end-message">
            <h2 id="endGameMessage"></h2>
            <p>Refresh the page to start a new game</p>
        </div>
    </div>

    <div class="container">
        <div class="game-info">
            <h1>Chess Online</h1>
            <div id="messageContainer"></div>
            <div class="room-controls">
                <button id="createRoom">Create Room</button>
                <input type="text" id="roomCode" placeholder="Enter Room Code" maxlength="6">
                <button id="joinRoom">Join Room</button>
                <p id="roomStatus"></p>
            </div>
            <p id="status"></p>
        </div>

        <div class="board-container">
            <div class="side-panel">
                <h3>Captured White Pieces</h3>
                <div id="capturedBlack" class="captured-pieces"></div>
                <h3>Move History</h3>
                <div id="moveHistory"></div>
            </div>
            <div id="board"></div>
            <div class="side-panel">
                <h3>Captured Black Pieces</h3>
                <div id="capturedWhite" class="captured-pieces"></div>
            </div>
        </div>
    </div>

    <button class="show-errors" onclick="toggleErrorLog()">Show Errors</button>
    <div id="errorLog"></div>

    <audio id="moveSound" src="data:audio/mp3;base64,SUQzBAAAAAAAI1RTU0UAAAAPAAADTGF2ZjU4LjI5LjEwMAAAAAAAAAAAAAAA//tQwAAAAAAAAAAAAAAAAAAAAAAASW5mbwAAAA8AAAADAAAGhgBVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVWqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqr///////////////////////////////////////////8AAAAATGF2YzU4LjU0AAAAAAAAAAAAAAAAJAAAAAAAAAAAAoZxhxX2AAAAAAAAAAAAAAAAAAAA//tQxAAACVDlIgQwYgEjmWc/PCAAAFBHAAAAAAA0kBIAAAEkAAAAACEkBIAAAEkAAAAACQAAP/qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqr/+xDE1gPAAAGkAAAAIAAANIAAAASqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqg==" preload="auto"></audio>
    <audio id="captureSound" src="data:audio/mp3;base64,SUQzBAAAAAAAI1RTU0UAAAAPAAADTGF2ZjU4LjI5LjEwMAAAAAAAAAAAAAAA//tQwAAAAAAAAAAAAAAAAAAAAAAASW5mbwAAAA8AAAADAAAGhgBVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVWqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqr///////////////////////////////////////////8AAAAATGF2YzU4LjU0AAAAAAAAAAAAAAAAJAAAAAAAAAAAAoZxhxX2AAAAAAAAAAAAAAAAAAAA//tQxAAACZjpQgQwYgEvnSn/PCAAAPgnAAAAAAAA0kAIAAAEkAAAAABpIAQAAAJIAAAAABIAAH/6qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqv/7EMTWg8AAAaQAAAAgAAA0gAAABKqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq" preload="auto"></audio>

    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>
    <script src="/socket.io/socket.io.js"></script>
    <script>
        // Enhanced error handling and state management
        class ChessGameManager {
            constructor() {
                this.idleTimeoutDuration = 300000; // 5 minutes
                this.lastActivityTime = Date.now();
                this.checkIdleInterval = setInterval(() => this.checkIdleTimeout(), 10000);

                this.socket = null;
                this.board = null;
                this.game = new Chess();
                this.playerColor = 'w';
                this.currentRoom = null;
                this.isMyTurn = false;
                this.premoveFrom = null;
                this.premoveTo = null;
                this.selectedSquare = null;
                this.pendingMove = false;
                this.connectionAttempts = 0;
                this.maxConnectionAttempts = 5;
                this.reconnectTimeout = null;
                this.moveTimeout = null;
                this.errors = [];
                this.lastHeartbeat = Date.now();
                this.heartbeatInterval = null;
                
                this.initializeSocket();
                this.setupEventListeners();
                this.initGame();
                this.startHeartbeat();
            }

            // Enhanced error logging
            logError(error, context = '') {
                const errorEntry = {
                    timestamp: new Date().toISOString(),
                    error: error.toString(),
                    context: context,
                    stack: error.stack || 'No stack trace'
                };
                
                this.errors.push(errorEntry);
                if (this.errors.length > 50) {
                    this.errors.shift(); // Keep only last 50 errors
                }
                
                console.error(`[${context}]`, error);
                this.updateErrorDisplay();
            }

            updateErrorDisplay() {
                const errorLog = document.getElementById('errorLog');
                if (this.errors.length > 0) {
                    errorLog.innerHTML = this.errors.slice(-10).map(err => 
                        `<div>${err.timestamp} - ${err.context}: ${err.error}</div>`
                    ).join('');
                }
            }

            // Enhanced socket initialization with retry logic
            initializeSocket() {
                try {
                    this.socket = io({
                        timeout: 10000,
                        reconnection: true,
                        reconnectionAttempts: this.maxConnectionAttempts,
                        reconnectionDelay: 1000,
                        reconnectionDelayMax: 5000
                    });

                    this.setupSocketEventHandlers();
                } catch (error) {
                    this.logError(error, 'Socket Initialization');
                    this.showMessage('Failed to initialize connection', 'error');
                }
            }

            setupSocketEventHandlers() {
                // Connection events
                this.socket.on('connect', () => {
                    this.connectionAttempts = 0;
                    this.updateConnectionStatus('connected');
                    this.showMessage('Connected to server', 'success');
                    this.clearReconnectTimeout();
                });

                this.socket.on('disconnect', (reason) => {
                    this.updateConnectionStatus('disconnected');
                    this.showMessage(`Connection lost: ${reason}`, 'error');
                    this.logError(new Error(`Disconnected: ${reason}`), 'Socket Disconnect');
                    
                    if (reason === 'io server disconnect') {
                        // Server disconnected, need to reconnect manually
                        this.attemptReconnect();
                    }
                });

                this.socket.on('connect_error', (error) => {
                    this.connectionAttempts++;
                    this.updateConnectionStatus('reconnecting');
                    this.logError(error, 'Connection Error');
                    
                    if (this.connectionAttempts >= this.maxConnectionAttempts) {
                        this.showMessage('Unable to connect to server. Please refresh the page.', 'error');
                    }
                });

                this.socket.on('reconnect', (attemptNumber) => {
                    this.updateConnectionStatus('connected');
                    this.showMessage(`Reconnected after ${attemptNumber} attempts`, 'success');
                });

                this.socket.on('reconnect_attempt', () => {
                    this.updateConnectionStatus('reconnecting');
                });

                // Game events with validation
                this.socket.on('roomCreated', (data) => {
                    if (this.validateRoomData(data)) {
                        this.currentRoom = typeof data === 'string' ? data : data.roomCode;
                        $('#roomStatus').text(`Room Created: ${this.currentRoom}`);
                        this.showMessage('Room created successfully', 'success');
                    }
                });

                this.socket.on('joinedRoom', (data) => {
                    if (this.validateRoomData(data)) {
                        this.currentRoom = typeof data === 'string' ? data : data.roomCode;
                        $('#roomStatus').text(`Joined Room: ${this.currentRoom}`);
                        this.showMessage('Joined room successfully', 'success');
                    }
                });

                this.socket.on('gameStart', (data) => {
                    if (this.validateGameStartData(data)) {
                        this.playerColor = this.socket.id === data.white ? 'w' : 'b';
                        this.isMyTurn = this.playerColor === 'w';
                        this.reinitializeBoard();
                        $('#roomStatus').text(`Game Started - You are ${this.playerColor === 'w' ? 'White' : 'Black'}`);
                        this.showMessage('Game started!', 'success');
                    }
                });

                this.socket.on('moveMade', (data) => {
                    if (this.validateMoveData(data)) {
                        this.handleOpponentMove(data);
                    }
                });

                this.socket.on('gameOver', (result) => {
                    if (typeof result === 'string' && result.trim()) {
                        $('#endGameMessage').text(result);
                        $('.game-end-overlay').css('display', 'flex');
                        this.isMyTurn = false;
                    }
                });

                this.socket.on('playerLeft', () => {
                    $('#roomStatus').text('Opponent left the game');
                    this.isMyTurn = false;
                    this.showMessage('Opponent left the game', 'error');
                });

                this.socket.on('roomError', (message) => {
                    const errorMsg = typeof message === 'string' ? message : 'Room error occurred';
                    $('#roomStatus').text(errorMsg);
                    this.showMessage(errorMsg, 'error');
                });

                // Heartbeat for connection monitoring
                this.socket.on('pong', () => {
                    this.updateActivityTime();
                    this.lastHeartbeat = Date.now();
                });
            }

            // Data validation methods
            validateRoomData(data) {
                if (!data) {
                    this.logError(new Error('Room data is null or undefined'), 'Room Validation');
                    return false;
                }
                
                const roomCode = typeof data === 'string' ? data : data.roomCode;
                if (!roomCode || typeof roomCode !== 'string' || roomCode.length < 3) {
                    this.logError(new Error('Invalid room code format'), 'Room Validation');
                    return false;
                }
                
                return true;
            }

            validateGameStartData(data) {
                if (!data || typeof data !== 'object') {
                    this.logError(new Error('Game start data is invalid'), 'Game Start Validation');
                    return false;
                }
                
                if (!data.white || !data.black || typeof data.white !== 'string' || typeof data.black !== 'string') {
                    this.logError(new Error('Invalid player data in game start'), 'Game Start Validation');
                    return false;
                }
                
                return true;
            }

            validateMoveData(data) {
                if (!data || typeof data !== 'object') {
                    this.logError(new Error('Move data is invalid'), 'Move Validation');
                    return false;
                }
                
                if (!data.from || !data.to || !data.fen) {
                    this.logError(new Error('Move data missing required fields'), 'Move Validation');
                    return false;
                }
                
                // Validate FEN format
                try {
                    const testGame = new Chess();
                    testGame.load(data.fen);
                } catch (error) {
                    this.logError(new Error('Invalid FEN in move data'), 'Move Validation');
                    return false;
                }
                
                return true;
            }

            // Enhanced connection management
            attemptReconnect() {
                if (this.reconnectTimeout) return;
                
                this.reconnectTimeout = setTimeout(() => {
                    this.socket.connect();
                    this.reconnectTimeout = null;
                }, 2000);
            }

            clearReconnectTimeout() {
                if (this.reconnectTimeout) {
                    clearTimeout(this.reconnectTimeout);
                    this.reconnectTimeout = null;
                }
            }

            updateConnectionStatus(status) {
                const statusElement = document.getElementById('connectionStatus');
                statusElement.className = `connection-status ${status}`;
                
                switch (status) {
                    case 'connected':
                        statusElement.textContent = 'Connected';
                        break;
                    case 'disconnected':
                        statusElement.textContent = 'Disconnected';
                        break;
                    case 'reconnecting':
                        statusElement.textContent = 'Reconnecting...';
                        break;
                }
            }

            startHeartbeat() {
                this.heartbeatInterval = setInterval(() => {
                    if (this.socket && this.socket.connected) {
                        this.socket.emit('ping');
                        
                        // Check if we haven't received a pong in a while
                        if (Date.now() - this.lastHeartbeat > 30000) {
                            this.logError(new Error('Heartbeat timeout'), 'Heartbeat');
                            this.socket.disconnect();
                        }
                    }
                }, 15000);
            }

            // Enhanced move handling with multiple move prevention
            handleOpponentMove(data) {
                this.updateActivityTime();
                try {
                    this.game.load(data.fen);
                    this.board.position(data.fen);

                    $('.square-55d63').removeClass('last-move');
                    
                    $(`.square-${data.from}`).addClass('last-move');
                    $(`.square-${data.to}`).addClass('last-move');
                    
                    this.isMyTurn = this.game.turn() === this.playerColor;

                    const sound = document.getElementById(data.move && data.move.captured ? 'captureSound' : 'moveSound');
                    if (sound) {
                        sound.currentTime = 0;
                        sound.play().catch(e => this.logError(e, 'Audio Play'));
                    }
                    
                    this.updateStatus();
                    this.updateCapturedPieces();
                    if (data.move) {
                        this.updateMoveHistory(data.move);
                    }
                    this.updateCheckHighlight();
                    
                    this.tryPremove();
                    
                    // Clear any pending move timeouts
                    this.clearMoveTimeout();
                    
                } catch (error) {
                    this.logError(error, 'Handle Opponent Move');
                    this.showMessage('Error processing opponent move', 'error');
                }
            }

            // Move timeout handling
            setMoveTimeout() {
                this.clearMoveTimeout();
                this.moveTimeout = setTimeout(() => {
                    if (this.pendingMove) {
                        this.pendingMove = false;
                        this.showMessage('Move timed out, please try again', 'error');
                        this.enableButtons();
                    }
                }, 10000); // 10 second timeout
            }

            clearMoveTimeout() {
                if (this.moveTimeout) {
                    clearTimeout(this.moveTimeout);
                    this.moveTimeout = null;
                }
            }

            // Enhanced move making with duplicate prevention
            makeMove(from, to) {
                if (this.pendingMove) {
                    this.showMessage('Please wait for your previous move to complete', 'error');
                    return null;
                }

                if (!this.isMyTurn) {
                    this.showMessage('It\'s not your turn', 'error');
                    return null;
                }

                try {
                    const move = this.game.move({ from, to, promotion: 'q' });
                    if (move) {
                        this.board.position(this.game.fen());
                        this.updateStatus();
                        
                        // Prevent multiple moves
                        this.pendingMove = true;
                        this.disableButtons();
                        this.setMoveTimeout();
                        
                        return move;
                    }
                } catch (error) {
                    this.logError(error, 'Make Move');
                    this.showMessage('Invalid move', 'error');
                }
                return null;
            }

            // Button state management
            disableButtons() {
                $('#createRoom, #joinRoom').prop('disabled', true);
            }

            enableButtons() {
                $('#createRoom, #joinRoom').prop('disabled', false);
            }

            // Enhanced message display
            showMessage(message, type = 'info') {
                const messageContainer = $('#messageContainer');
                const messageElement = $(`<div class="${type}-message">${message}</div>`);
                
                messageContainer.empty().append(messageElement);
                
                setTimeout(() => {
                    messageElement.fadeOut(() => messageElement.remove());
                }, 5000);
            }

            // Room creation and joining with validation
            createRoom() {
                if (!this.socket || !this.socket.connected) {
                    this.showMessage('Not connected to server', 'error');
                    return;
                }

                try {
                    this.socket.emit('createRoom');
                    this.disableButtons();
                    setTimeout(() => this.enableButtons(), 2000);
                } catch (error) {
                    this.logError(error, 'Create Room');
                    this.showMessage('Failed to create room', 'error');
                }
            }

            joinRoom() {
                const roomCode = $('#roomCode').val().trim().toUpperCase();
                
                if (!roomCode) {
                    this.showMessage('Please enter a room code', 'error');
                    return;
                }
                
                if (roomCode.length < 3) {
                    this.showMessage('Room code must be at least 3 characters', 'error');
                    return;
                }

                if (!this.socket || !this.socket.connected) {
                    this.showMessage('Not connected to server', 'error');
                    return;
                }

                try {
                    this.socket.emit('joinRoom', roomCode);
                    this.disableButtons();
                    setTimeout(() => this.enableButtons(), 2000);
                } catch (error) {
                    this.logError(error, 'Join Room');
                    this.showMessage('Failed to join room', 'error');
                }
            }

            updateCheckHighlight() {
                try {
                    $('.square-55d63').removeClass('in-check');
                    if (this.game.in_check()) {
                        const turn = this.game.turn();
                        const board = this.game.board();
                        for (let i = 0; i < 8; i++) {
                            for (let j = 0; j < 8; j++) {
                                const piece = board[i][j];
                                if (piece && piece.type === 'k' && piece.color === turn) {
                                    const square = String.fromCharCode(97 + j) + (8 - i);
                                    $(`.square-${square}`).addClass('in-check');
                                }
                            }
                        }
                    }
                } catch (error) {
                    this.logError(error, 'Update Check Highlight');
                }
            }

            updateCapturedPieces() {
                try {
                    const positions = this.game.board();
                    const currentPieces = { w: {}, b: {} };
                    'prnbqk'.split('').forEach(piece => {
                        currentPieces.w[piece] = 0;
                        currentPieces.b[piece] = 0;
                    });
                    
                    positions.forEach(row => {
                        row.forEach(piece => {
                            if (piece) {
                                currentPieces[piece.color][piece.type]++;
                            }
                        });
                    });
                    
                    const initialCounts = { p: 8, r: 2, n: 2, b: 2, q: 1, k: 1 };
                    const capturedPieces = { w: [], b: [] };
                    
                    ['w', 'b'].forEach(color => {
                        Object.entries(initialCounts).forEach(([piece, count]) => {
                            const captured = count - currentPieces[color][piece];
                            for (let i = 0; i < captured; i++) {
                                capturedPieces[color].push(piece);
                            }
                        });
                    });

                    $('#capturedWhite').html(capturedPieces.w.map(p =>
                        `<img src="https://chessboardjs.com/img/chesspieces/wikipedia/w${p.toUpperCase()}.png" alt="white ${p}">`
                    ).join(''));
                    
                    $('#capturedBlack').html(capturedPieces.b.map(p =>
                        `<img src="https://chessboardjs.com/img/chesspieces/wikipedia/b${p.toUpperCase()}.png" alt="black ${p}">`
                    ).join(''));
                } catch (error) {
                    this.logError(error, 'Update Captured Pieces');
                }
            }

            updateMoveHistory(move) {
                try {
                    const history = this.game.history();
                    const lastMove = history[history.length - 1];
                    const moveNumber = Math.ceil(history.length / 2);
                    const moveRow = $('<div class="move-row"></div>');
                    
                    if (this.game.turn() === 'b') {
                        moveRow.html(
                            `<span class="move-number">${moveNumber}.</span>` +
                            `<span class="move">${lastMove}</span>` +
                            `<span class="move"></span>`
                        );
                        $('#moveHistory').append(moveRow);
                    } else {
                        const lastRow = $('#moveHistory .move-row').last();
                        if (lastRow.length && lastRow.find('.move').last().text() === '') {
                            lastRow.find('.move').last().text(lastMove);
                        } else {
                            moveRow.html(
                                `<span class="move-number">${moveNumber}.</span>` +
                                `<span class="move"></span>` +
                                `<span class="move">${lastMove}</span>`
                            );
                            $('#moveHistory').append(moveRow);
                        }
                    }
                    
                    $('#moveHistory').scrollTop($('#moveHistory')[0].scrollHeight);
                } catch (error) {
                    this.logError(error, 'Update Move History');
                }
            }

            handlePremove(square) {
                try {
                    if (!this.isMyTurn && this.premoveFrom === null) {
                        this.premoveFrom = square;
                        $(`.square-${square}`).addClass('premove');
                    } else if (!this.isMyTurn && this.premoveFrom !== null) {
                        this.premoveTo = square;
                        if (this.premoveFrom !== this.premoveTo) {
                            $('.square-55d63').removeClass('premove');
                            this.tryPremove();
                        }
                    }
                } catch (error) {
                    this.logError(error, 'Handle Premove');
                }
            }

            tryPremove() {
                if (this.premoveFrom && this.premoveTo && this.isMyTurn && !this.pendingMove) {
                    try {
                        const move = this.makeMove(this.premoveFrom, this.premoveTo);
                        if (move) {
                            this.socket.emit('move', {
                                from: this.premoveFrom,
                                to: this.premoveTo,
                                roomCode: this.currentRoom
                            });
                        }
                    } catch (error) {
                        this.logError(error, 'Try Premove');
                    } finally {
                        this.premoveFrom = null;
                        this.premoveTo = null;
                    }
                }
            }

            updateStatus() {
                try {
                    let status = '';
                    if (this.game.in_checkmate()) {
                        status = `Game Over - ${this.game.turn() === 'w' ? 'Black' : 'White'} wins by checkmate!`;
                    } else if (this.game.in_draw()) {
                        status = 'Game Over - Draw!';
                    } else {
                        status = `${this.game.turn() === 'w' ? 'White' : 'Black'} to move`;
                        if (this.game.in_check()) {
                            status += ' (CHECK)';
                        }
                    }
                    $('#status').text(status);
                } catch (error) {
                    this.logError(error, 'Update Status');
                }
            }

            handleSquareClick(event) {
                this.updateActivityTime();
                try {
                    const square = $(event.currentTarget).data('square');
                    const piece = this.game.get(square);

                    if (!this.isMyTurn) {
                        this.handlePremove(square);
                        return;
                    }

                    if (this.pendingMove) {
                        this.showMessage('Please wait for your move to complete', 'error');
                        return;
                    }

                    if (this.selectedSquare === null) {
                        if (piece && piece.color === this.playerColor) {
                            this.selectedSquare = square;
                            this.highlightLegalMoves(square);
                            $(event.currentTarget).addClass('selected-square');
                        }
                    } else {
                        const move = this.makeMove(this.selectedSquare, square);
                        $('.square-55d63').removeClass('selected-square highlight-square');
                        const oldSelectedSquare = this.selectedSquare;
                        this.selectedSquare = null;

                        if (move) {
                            try {
                                this.socket.emit('move', {
                                    from: move.from,
                                    to: move.to,
                                    roomCode: this.currentRoom
                                });
                                
                                // Handle successful move emission
                                setTimeout(() => {
                                    this.pendingMove = false;
                                    this.enableButtons();
                                    this.clearMoveTimeout();
                                }, 1000);
                                
                            } catch (error) {
                                this.logError(error, 'Socket Emit Move');
                                this.showMessage('Failed to send move', 'error');
                                this.pendingMove = false;
                                this.enableButtons();
                                this.clearMoveTimeout();
                            }
                        }
                    }
                } catch (error) {
                    this.logError(error, 'Handle Square Click');
                }
            }

            highlightLegalMoves(square) {
                try {
                    $('.square-55d63').removeClass('highlight-square');
                    const moves = this.game.moves({ square: square, verbose: true });
                    moves.forEach(move => {
                        $(`[data-square="${move.to}"]`).addClass('highlight-square');
                    });
                } catch (error) {
                    this.logError(error, 'Highlight Legal Moves');
                }
            }

            setupEventListeners() {
                $('#createRoom').click(() => this.createRoom());
                $('#joinRoom').click(() => this.joinRoom());

                $('#roomCode').on('keypress', (e) => {
                    if (e.which === 13) { // Enter key
                        this.joinRoom();
                    }
                });

                $('#themeSelect').change(function() {
                    const theme = $(this).val();
                    $('body').removeClass().addClass(`theme-${theme}`);
                });

                // Handle page visibility changes
                document.addEventListener('visibilitychange', () => {
                    if (document.hidden) {
                        // Page is hidden, reduce activity
                        if (this.heartbeatInterval) {
                            clearInterval(this.heartbeatInterval);
                        }
                    } else {
                        // Page is visible again, resume activity
                        this.startHeartbeat();
                    }
                });

                // Handle page unload
                window.addEventListener('beforeunload', () => {
                    if (this.socket && this.socket.connected) {
                        this.socket.disconnect();
                    }
                });
            }

            initGame() {
                try {
                    this.board = Chessboard('board', {
                        position: 'start',
                        orientation: this.playerColor === 'b' ? 'black' : 'white',
                        pieceTheme: 'https://chessboardjs.com/img/chesspieces/wikipedia/{piece}.png',
                        draggable: false
                    });

                    $('.square-55d63').on('click', (event) => this.handleSquareClick(event));
                    
                    this.updateStatus();
                } catch (error) {
                    this.logError(error, 'Initialize Game');
                    this.showMessage('Failed to initialize game board', 'error');
                }
            }

            reinitializeBoard() {
                try {
                    if (this.board) {
                        this.board.destroy();
                    }
                    
                    this.board = Chessboard('board', {
                        position: 'start',
                        orientation: this.playerColor === 'b' ? 'black' : 'white',
                        pieceTheme: 'https://chessboardjs.com/img/chesspieces/wikipedia/{piece}.png',
                        draggable: false
                    });

                    $('.square-55d63').off('click').on('click', (event) => this.handleSquareClick(event));
                    
                    this.updateStatus();
                } catch (error) {
                    this.logError(error, 'Reinitialize Board');
                    this.showMessage('Failed to reinitialize game board', 'error');
                }
            }

            
            checkIdleTimeout() {
                if (Date.now() - this.lastActivityTime > this.idleTimeoutDuration) {
                    this.showMessage('Disconnected due to inactivity.', 'error');
                    this.socket.disconnect();
                    clearInterval(this.checkIdleInterval);
                }
            }

            updateActivityTime() {
                this.lastActivityTime = Date.now();
            }

            // Cleanup method
            destroy() {
                try {
                    if (this.heartbeatInterval) {
                        clearInterval(this.heartbeatInterval);
                    }
                    
                    if (this.reconnectTimeout) {
                        clearTimeout(this.reconnectTimeout);
                    }
                    
                    if (this.moveTimeout) {
                        clearTimeout(this.moveTimeout);
                    }
                    
                    if (this.socket) {
                        this.socket.disconnect();
                    }
                    
                    if (this.board) {
                        this.board.destroy();
                    }
                } catch (error) {
                    this.logError(error, 'Destroy');
                }
            }
        }

        // Global error handling
        window.addEventListener('error', (event) => {
            if (window.chessGame) {
                window.chessGame.logError(event.error, 'Global Error');
            }
        });

        window.addEventListener('unhandledrejection', (event) => {
            if (window.chessGame) {
                window.chessGame.logError(new Error(event.reason), 'Unhandled Promise Rejection');
            }
        });

        // Error log toggle function
        function toggleErrorLog() {
            const errorLog = document.getElementById('errorLog');
            if (errorLog.style.display === 'none' || errorLog.style.display === '') {
                errorLog.style.display = 'block';
            } else {
                errorLog.style.display = 'none';
            }
        }

        // Initialize the game when document is ready
        $(document).ready(() => {
            try {
                window.chessGame = new ChessGameManager();
            } catch (error) {
                console.error('Failed to initialize chess game:', error);
                document.getElementById('messageContainer').innerHTML = 
                    '<div class="error-message">Failed to initialize game. Please refresh the page.</div>';
            }
        });
    </script>
</body>
</html>
